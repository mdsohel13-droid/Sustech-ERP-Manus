ROLE & RESPONSIBILITY

You are acting as a principal ERP architect and senior full-stack engineer reviewing and stabilizing a prebuilt ERP system generated by Manus AI.

Your responsibility is system-wide correction and alignment, not module-by-module patching.

You must think like the final owner of this ERP.

CORE OBJECTIVE

Perform a holistic audit, refactor, UI alignment, and validation of the entire ERP so that:

All modules behave consistently

All dashboards show truthful, real-time data

All cross-module relationships are enforced

UI/UX follows a unified design language

Database design supports long-term scalability

Future upgrades do not cause regressions

Your work must eliminate repetitive fixes and credit-heavy iteration cycles.

INPUTS YOU WILL RECEIVE

You will be provided with:

Full ERP source code (frontend + backend)

PostgreSQL + Drizzle database schema

Known issue patterns and audit summary

Dashboard screenshots for EACH module (Tender, Sales, Projects, Inventory, Finance, CRM, etc.)

Each screenshot represents:

Required UI layout

Required KPIs

Information hierarchy

Interaction patterns

Navigation expectations

Treat screenshots as authoritative functional UI/UX references, not optional inspiration.

HOW YOU MUST USE THE ATTACHED DASHBOARD IMAGES

This instruction is mandatory.

For each module, you must:

Study the attached dashboard image carefully

Identify:

Required data points

KPI definitions

Table structure

Filters, tabs, and status groupings

Popups, drill-downs, and navigation flows

Map each visual element to:

Actual database fields

Correct backend queries

Proper API responses

You must then:

Implement or upgrade the module dashboard to match the image’s intent

Reuse the same UI/UX pattern (cards, tables, badges, colors, layout logic) across all modules

Ensure consistency in:

Status badges

Date handling

Filters (active / archived / status-based)

Drill-down behavior

If a feature appears in the image but does not exist in code, add it properly with:

Backend support

Database linkage

Correct state management

Do not fake UI elements with hardcoded or derived values.

PHASE 1: SYSTEM-WIDE DATABASE AUDIT & STREAMLINING

Audit all tables and relations:

Ensure all business entities support soft delete (archivedAt)

Remove backend filtering that hides valid data unintentionally

Replace MySQL-only patterns (insertId, NOW())

Enforce PostgreSQL .returning({ id })

Normalize relationships across modules

Verify and streamline relationships among:

Customers

Tender / Quotation

Sales

Projects

Inventory

Products

Payments / AR / AP

Audit Logs

Users

Eliminate duplication and weak foreign-key logic.

PHASE 2: API & BUSINESS LOGIC CONSISTENCY

Audit all API routes and mutations:

Ensure { input, ctx } is used wherever user context is required

Enforce Zod validation everywhere

Convert all date strings to Date before persistence

Combine status change and archive logic into atomic updates

Invalidate queries after mutations correctly

Implement and verify status-driven automation, including:

Tender/Quotation → Project (Win / PO Received)

Loss → Auto archive

Sales → Inventory adjustment

Paid → AR/AP update

Financial actions → Audit log entry

These rules must be consistent across modules.

PHASE 3: FRONTEND STATE, DATA FLOW & DASHBOARD ACCURACY

Audit all frontend components:

Status badges must reflect real database fields

Tables must display persisted values

useMemo dependencies must include raw data arrays

Dashboard KPIs must update instantly after mutations

Archived filtering must occur on frontend, not backend

Ensure no visual correctness hides data inconsistency.

PHASE 4: MODULE DASHBOARD IMPLEMENTATION (IMAGE-DRIVEN)

For each module:

Implement or refactor dashboard strictly following its attached image

Ensure:

KPIs are correctly calculated

Tables are searchable and filterable

Popups show correlated information

Click-through navigation works end-to-end

Maintain:

Inter-module linking

Consistent UX behavior

Shared component logic

PHASE 5: CROSS-MODULE CORRELATION & DATA INTEGRITY

Explicitly verify:

Customers are single-source and reused everywhere

Tender → Sales → Project → Finance lifecycle continuity

Inventory links correctly to Sales and Products

Projects retain traceability to source Tender/Quotation

No orphan records exist

Document any enforced assumptions.

PHASE 6: SYSTEM VALIDATION & RELIABILITY TESTING

Before completion, confirm:

All status transitions work correctly

Archive/restore behaves predictably

Dashboards update immediately

All UI actions trigger correct backend logic

No data disappears silently

No regression introduced

Run integrity checks on:

Archived records

Project auto-creation

Financial traceability

FINAL OUTPUT REQUIREMENTS

Provide:

Summary of architectural corrections

List of stabilized modules

Schema changes (if any)

UI/UX alignment notes based on screenshots

Confirmation that the ERP is now stable for incremental development

NON-NEGOTIABLE PRINCIPLE

Optimize for:

Minimum future fixes

Minimum Replit credit consumption

Maximum architectural clarity

Do not stop at visible bugs.
Finish only when the ERP behaves as one coherent system, both technically and visually.